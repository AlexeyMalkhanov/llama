Index: src/test/org/apache/hadoop/mapred/MiniMRCluster.java
===================================================================
--- src/test/org/apache/hadoop/mapred/MiniMRCluster.java	(revision 686180)
+++ src/test/org/apache/hadoop/mapred/MiniMRCluster.java	(working copy)
@@ -17,17 +17,20 @@
  */
 package org.apache.hadoop.mapred;
 
-import java.io.*;
-import java.util.*;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.net.DNSToSwitchMapping;
+import org.apache.hadoop.net.NetUtils;
 import org.apache.hadoop.net.NetworkTopology;
 import org.apache.hadoop.net.StaticMapping;
-import org.apache.hadoop.net.NetUtils;
 import org.apache.hadoop.security.UnixUserGroupInformation;
-import org.apache.hadoop.fs.FileSystem;
 
 /**
  * This class creates a single-process Map-Reduce cluster for junit testing.
@@ -50,6 +53,8 @@
   private String namenode;
   private UnixUserGroupInformation ugi = null;
     
+  private JobConf job;
+  
   /**
    * An inner class that runs a job tracker.
    */
@@ -212,8 +217,7 @@
    * @return the absolute pathname of the local dir
    */
   public String getTaskTrackerLocalDir(int taskTracker) {
-    return ((TaskTrackerRunner) 
-            taskTrackerList.get(taskTracker)).getLocalDir();
+    return (taskTrackerList.get(taskTracker)).getLocalDir();
   }
 
   /**
@@ -227,8 +231,32 @@
    * Wait until the system is idle.
    */
   public void waitUntilIdle() {
-    for(Iterator itr= taskTrackerList.iterator(); itr.hasNext();) {
-      TaskTrackerRunner runner = (TaskTrackerRunner) itr.next();
+    waitTaskTrackers();
+    
+    JobClient client;
+    try {
+      client = new JobClient(job);
+      while(client.getClusterStatus().getTaskTrackers()<taskTrackerList.size()) {
+        for(TaskTrackerRunner runner : taskTrackerList) {
+          if(runner.isDead) {
+            throw new RuntimeException("TaskTracker is dead");
+          }
+        }
+        Thread.sleep(1000);
+      }
+    }
+    catch (IOException ex) {
+      throw new RuntimeException(ex);
+    }
+    catch (InterruptedException ex) {
+      throw new RuntimeException(ex);
+    }
+    
+  }
+
+  private void waitTaskTrackers() {
+    for(Iterator<TaskTrackerRunner> itr= taskTrackerList.iterator(); itr.hasNext();) {
+      TaskTrackerRunner runner = itr.next();
       while (!runner.isDead && (!runner.isInitialized || !runner.tt.isIdle())) {
         if (!runner.isInitialized) {
           LOG.info("Waiting for task tracker to start.");
@@ -242,7 +270,7 @@
       }
     }
   }
-
+  
   /** 
    * Get the actual rpc port used.
    */
@@ -255,6 +283,9 @@
   }
 
   public JobConf createJobConf(JobConf conf) {
+    if(conf == null) {
+      conf = new JobConf();
+    }
     JobConf result = new JobConf(conf);
     FileSystem.setDefaultUri(result, namenode);
     result.set("mapred.job.tracker", "localhost:"+jobTrackerPort);
@@ -385,7 +416,7 @@
     this.numTaskTrackers = numTaskTrackers;
     this.namenode = namenode;
     this.ugi = ugi;
-
+    
     // Create the JobTracker
     jobTracker = new JobTrackerRunner(conf);
     jobTrackerThread = new Thread(jobTracker);
@@ -425,7 +456,8 @@
     for (Thread taskTrackerThread : taskTrackerThreadList){
       taskTrackerThread.start();
     }
-
+    
+    this.job = createJobConf(conf);
     waitUntilIdle();
   }
     
@@ -434,10 +466,10 @@
    */
   public void shutdown() {
     try {
-      waitUntilIdle();
+      waitTaskTrackers();
       for (int idx = 0; idx < numTaskTrackers; idx++) {
-        TaskTrackerRunner taskTracker = (TaskTrackerRunner) taskTrackerList.get(idx);
-        Thread taskTrackerThread = (Thread) taskTrackerThreadList.get(idx);
+        TaskTrackerRunner taskTracker = taskTrackerList.get(idx);
+        Thread taskTrackerThread = taskTrackerThreadList.get(idx);
         taskTracker.shutdown();
         taskTrackerThread.interrupt();
         try {
