diff --git a/src/core/org/apache/hadoop/ipc/Client.java b/src/core/org/apache/hadoop/ipc/Client.java
index 1aaefd6..8319dec 100644
--- a/src/core/org/apache/hadoop/ipc/Client.java
+++ b/src/core/org/apache/hadoop/ipc/Client.java
@@ -298,7 +298,7 @@ public class Client {
             this.socket = socketFactory.createSocket();
             this.socket.setTcpNoDelay(tcpNoDelay);
             // connection time out is 20s
-            this.socket.connect(remoteId.getAddress(), 20000);
+            NetUtils.connect(this.socket, remoteId.getAddress(), 20000);
             this.socket.setSoTimeout(pingInterval);
             break;
           } catch (SocketTimeoutException toe) {
diff --git a/src/core/org/apache/hadoop/net/NetUtils.java b/src/core/org/apache/hadoop/net/NetUtils.java
index 7e1906d..4c624ad 100644
--- a/src/core/org/apache/hadoop/net/NetUtils.java
+++ b/src/core/org/apache/hadoop/net/NetUtils.java
@@ -22,7 +22,9 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.net.SocketAddress;
 import java.net.URI;
+import java.nio.channels.SocketChannel;
 import java.util.Map.Entry;
 import java.util.*;
 
@@ -366,4 +368,39 @@ public class NetUtils {
     return (socket.getChannel() == null) ? 
             socket.getOutputStream() : new SocketOutputStream(socket, timeout);            
   }
+
+  /**
+   * This is a drop-in replacement for 
+   * {@link Socket#connect(SocketAddress, int)}.
+   * In the case of normal sockets that don't have associated channels, this 
+   * just invokes <code>socket.connect(endpoint, timeout)</code>. If 
+   * <code>socket.getChannel()</code> returns a non-null channel,
+   * connect is implemented using Hadoop's selectors. This is done mainly
+   * to avoid Sun's connect implementation from creating thread-local 
+   * selectors, since Hadoop does not have control on when these are closed
+   * and could end up taking all the available file descriptors.
+   * 
+   * @see java.net.Socket#connect(java.net.SocketAddress, int)
+   * 
+   * @param socket
+   * @param endpoint 
+   * @param timeout - timeout in milliseconds
+   */
+  public static void connect(Socket socket, 
+                             SocketAddress endpoint, 
+                             int timeout) throws IOException {
+    if (socket == null || endpoint == null || timeout < 0) {
+      throw new IllegalArgumentException("Illegal argument for connect()");
+    }
+    
+    SocketChannel ch = socket.getChannel();
+    
+    if (ch == null) {
+      // let the default implementation handle it.
+      socket.connect(endpoint, timeout);
+    } else {
+      SocketIOWithTimeout.connect(ch, endpoint, timeout);
+    }
+  }
+
 }
diff --git a/src/core/org/apache/hadoop/net/SocketIOWithTimeout.java b/src/core/org/apache/hadoop/net/SocketIOWithTimeout.java
index c24a8a8..f48d2d2 100644
--- a/src/core/org/apache/hadoop/net/SocketIOWithTimeout.java
+++ b/src/core/org/apache/hadoop/net/SocketIOWithTimeout.java
@@ -20,11 +20,13 @@ package org.apache.hadoop.net;
 
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.SocketAddress;
 import java.net.SocketTimeoutException;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
 import java.nio.channels.spi.SelectorProvider;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -159,7 +161,8 @@ abstract class SocketIOWithTimeout {
       } 
 
       if (count == 0) {
-        throw new SocketTimeoutException(timeoutExceptionString(ops));
+        throw new SocketTimeoutException(timeoutExceptionString(channel,
+                                                                timeout, ops));
       }
       // otherwise the socket should be ready for io.
     }
@@ -168,6 +171,64 @@ abstract class SocketIOWithTimeout {
   }
   
   /**
+   * The contract is similar to {@link SocketChannel#connect(SocketAddress)} 
+   * with a timeout.
+   * 
+   * @see SocketChannel#connect(SocketAddress)
+   * 
+   * @param channel - this should be a {@link SelectableChannel}
+   * @param endpoint
+   * @throws IOException
+   */
+  static void connect(SocketChannel channel, 
+                      SocketAddress endpoint, int timeout) throws IOException {
+    
+    boolean blockingOn = channel.isBlocking();
+    if (blockingOn) {
+      channel.configureBlocking(false);
+    }
+    
+    try { 
+      if (channel.connect(endpoint)) {
+        return;
+      }
+
+      long timeoutLeft = timeout;
+      long endTime = (timeout > 0) ? (System.currentTimeMillis() + timeout): 0;
+      
+      while (true) {
+        // we might have to call finishConnect() more than once
+        // for some channels (with user level protocols)
+        
+        int ret = selector.select((SelectableChannel)channel, 
+                                  SelectionKey.OP_CONNECT, timeoutLeft);
+        
+        if (ret > 0 && channel.finishConnect()) {
+          return;
+        }
+        
+        if (ret == 0 ||
+            (timeout > 0 &&  
+              (timeoutLeft = (endTime - System.currentTimeMillis())) <= 0)) {
+          throw new SocketTimeoutException(
+                    timeoutExceptionString(channel, timeout, 
+                                           SelectionKey.OP_CONNECT));
+        }
+      }
+    } catch (IOException e) {
+      // javadoc for SocketChannel.connect() says channel should be closed.
+      try {
+        channel.close();
+      } catch (IOException ignored) {}
+      throw e;
+    } finally {
+      if (blockingOn && channel.isOpen()) {
+        channel.configureBlocking(true);
+      }
+    }
+  }
+
+  /**
    * This is similar to {@link #doIO(ByteBuffer, int)} except that it
    * does not perform any I/O. It just waits for the channel to be ready
    * for I/O as specified in ops.
@@ -182,17 +243,28 @@ abstract class SocketIOWithTimeout {
   void waitForIO(int ops) throws IOException {
     
     if (selector.select(channel, ops, timeout) == 0) {
-      throw new SocketTimeoutException(timeoutExceptionString(ops)); 
+      throw new SocketTimeoutException(timeoutExceptionString(channel, timeout,
+                                                              ops)); 
     }
   }
-  
-  private String timeoutExceptionString(int ops) {
     
-    String waitingFor = "" + ops;
-    if (ops == SelectionKey.OP_READ) {
-      waitingFor = "read";
-    } else if (ops == SelectionKey.OP_WRITE) {
-      waitingFor = "write";
+  private static String timeoutExceptionString(SelectableChannel channel,
+                                               long timeout, int ops) {
+    
+    String waitingFor;
+    switch(ops) {
+    
+    case SelectionKey.OP_READ :
+      waitingFor = "read"; break;
+      
+    case SelectionKey.OP_WRITE :
+      waitingFor = "write"; break;      
+      
+    case SelectionKey.OP_CONNECT :
+      waitingFor = "connect"; break;
+      
+    default :
+      waitingFor = "" + ops;  
     }
     
     return timeout + " millis timeout while " +
diff --git a/src/hdfs/org/apache/hadoop/dfs/DFSClient.java b/src/hdfs/org/apache/hadoop/dfs/DFSClient.java
index c8ce403..0acd059 100644
--- a/src/hdfs/org/apache/hadoop/dfs/DFSClient.java
+++ b/src/hdfs/org/apache/hadoop/dfs/DFSClient.java
@@ -1325,7 +1325,7 @@ class DFSClient implements FSConstants {
 
         try {
           s = socketFactory.createSocket();
-          s.connect(targetAddr, socketTimeout);
+          NetUtils.connect(s, targetAddr, socketTimeout);
           s.setSoTimeout(socketTimeout);
           Block blk = targetBlock.getBlock();
           
@@ -1505,7 +1505,7 @@ class DFSClient implements FSConstants {
             
         try {
           dn = socketFactory.createSocket();
-          dn.connect(targetAddr, socketTimeout);
+          NetUtils.connect(dn, targetAddr, socketTimeout);
           dn.setSoTimeout(socketTimeout);
               
           int len = (int) (end - start + 1);
@@ -2381,7 +2381,7 @@ class DFSClient implements FSConstants {
         InetSocketAddress target = NetUtils.createSocketAddr(nodes[0].getName());
         s = socketFactory.createSocket();
         int timeoutValue = 3000 * nodes.length + socketTimeout;
-        s.connect(target, timeoutValue);
+        NetUtils.connect(s, target, timeoutValue);
         s.setSoTimeout(timeoutValue);
         s.setSendBufferSize(DEFAULT_DATA_SOCKET_SIZE);
         LOG.debug("Send buf size " + s.getSendBufferSize());
diff --git a/src/hdfs/org/apache/hadoop/dfs/DataNode.java b/src/hdfs/org/apache/hadoop/dfs/DataNode.java
index cfcc526..aac8537 100644
--- a/src/hdfs/org/apache/hadoop/dfs/DataNode.java
+++ b/src/hdfs/org/apache/hadoop/dfs/DataNode.java
@@ -1251,7 +1251,7 @@ public class DataNode extends Configured
             int timeoutValue = numTargets * socketTimeout;
             int writeTimeout = socketWriteTimeout + 
                                (WRITE_TIMEOUT_EXTENSION * numTargets);
-            mirrorSock.connect(mirrorTarget, timeoutValue);
+            NetUtils.connect(mirrorSock, mirrorTarget, timeoutValue);
             mirrorSock.setSoTimeout(timeoutValue);
             mirrorSock.setSendBufferSize(DEFAULT_DATA_SOCKET_SIZE);
             mirrorOut = new DataOutputStream(
@@ -1428,7 +1428,7 @@ public class DataNode extends Configured
         // get the output stream to the target
         InetSocketAddress targetAddr = NetUtils.createSocketAddr(target.getName());
         targetSock = newSocket();
-        targetSock.connect(targetAddr, socketTimeout);
+        NetUtils.connect(targetSock, targetAddr, socketTimeout);
         targetSock.setSoTimeout(socketTimeout);
 
         OutputStream baseStream = NetUtils.getOutputStream(targetSock, 
@@ -2901,7 +2901,7 @@ public class DataNode extends Configured
         InetSocketAddress curTarget = 
           NetUtils.createSocketAddr(targets[0].getName());
         sock = newSocket();
-        sock.connect(curTarget, socketTimeout);
+        NetUtils.connect(sock, curTarget, socketTimeout);
         sock.setSoTimeout(targets.length * socketTimeout);
 
         long writeTimeout = socketWriteTimeout + 
