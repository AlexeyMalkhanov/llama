#!/usr/bin/env python
# (c) Copyright 2009 Cloudera, Inc.
__usage = """
flags:
  -v   - verbose
  -y   - ask forgiveness, not permission

options:
  -a   - name of Apache remote to compare
 

tool is:
  branch - make a new branch from this point
  cust-branch [cust] - make a customer branch
  migrate-cust-branch [old-cust-branch] - migrate an existing customer branch onto trunk
  version [ref] - output version number for a ref
"""
import re
import sys
import subprocess

from optparse import OptionParser
from cdh_lib import git, git_rev_parse, cdh_get_version, git_cur_branch

VERBOSE = False
AUTOMATIC_YES = False
PREFIX = None
NO_PATCH_COUNT = False

def sideeffect_git(cmdv):
  """
  Run a git command that will have side effects.

  In default operation, this will ask for permission. It will also
  print out what it's doing if VERBOSE is set.

  Raises an Exception if the user denies permission.
  """
  if not AUTOMATIC_YES:
    print >>sys.stderr, "OK to run:", " ".join(cmdv)
    print >>sys.stderr, "(Y/n):"
    res = sys.stdin.readline().rstrip().lower()
    if res != 'y' and res != '':
      raise Exception("Command denied")
  if VERBOSE:
    print "+ %s" % (" ".join(cmdv))
  git(cmdv)

def usage(argv):
  """ Print usage and exit. """
  print >>sys.stderr, __usage
  sys.exit(1)

def branch(argv):
  """ Create a new branch from this point """
  version = cdh_get_version(git_cur_branch(), NO_PATCH_COUNT, PREFIX)
  sideeffect_git(['checkout', '-b', 'cdh-' + version])

def version(argv):
  """
  Print the version of the revision on the command line, or else that
  of HEAD.
  """

  ref = None
  if len(argv) == 3:
    ref = argv[2]

  if not ref:
    ref = git_cur_branch()

  print cdh_get_version(ref, NO_PATCH_COUNT, PREFIX)

def cust_branch(argv):
  """
  Create a customer branch from this point. For example, if you currently
  have the cdh-0.18.3 branch checked out, 58 revisions ahead of Apache, and
  you run this, it will first create the cdh-0.18.3+58 branch, then the
  cdh-0.18.3+58+custname branch.
  """
  if len(argv) != 3:
    usage(argv)
  make_cust_branch(argv[2])

def get_cust_branch_target(cust_name):
  head_ver = cdh_get_version(git_cur_branch(), NO_PATCH_COUNT, PREFIX)
  return 'cdh-%s+%s' % (head_ver, cust_name)

def ensure_head_version_branch(checkout=False):
  head_ver = cdh_get_version(git_cur_branch(), NO_PATCH_COUNT, PREFIX)
  branch = 'cdh-' + head_ver
  try:
    git_rev_parse('refs/heads/' + branch)
  except Exception, e:
    # No branch for this branch point yet, so make one
    sideeffect_git(['branch', branch, 'HEAD'])    
  if checkout:
    sideeffect_git(["checkout", branch])
  return branch

def make_cust_branch(cust_name):
  ensure_head_version_branch()
  sideeffect_git(['checkout', '-b', get_cust_branch_target(cust_name)])

def migrate_cust_branch(argv):
  if len(argv) != 3:
    usage(argv)
  old_branch = argv[2]

  m = re.match(r'^(cdh.+?)\+(\w+)$', old_branch)
  if not m:
    raise Exception("This branch doesn't match cdh-version+customername")
  src_base, cust_name = m.groups()
  patches = git(["log", "--pretty=oneline", "--abbrev-commit",
                 "%s..%s" % (src_base, old_branch)])
  target_base = git_cur_branch()
  target_branch = get_cust_branch_target(cust_name)

  print "Migrating customer branch for customer: %s" % cust_name
  print "-" * 80
  print "Customer branch base: %s" % src_base
  print "Customer-specific patches:"
  print "\n".join(["  " + p for p in patches.split("\n")])
  print "Target base: %s" % target_base
  print "Target branch: %s" % target_branch
  print "-" * 80

  # Make sure we have a branch for the current head
  head_ver_branch = ensure_head_version_branch()

  # Make a tmp branch copy of the old customer branch
  tmp_branch = 'cust_%s_tmp' % cust_name
  sideeffect_git(['checkout', '-b', tmp_branch, old_branch])

  # Rebase the old patches to the new location
  print sideeffect_git(['rebase', '--onto', head_ver_branch, src_base])

  # Make the new branch here
  sideeffect_git(['checkout', '-b', target_branch])

  # Kill the tmp
  sideeffect_git(['branch', '-d', tmp_branch])


TOOLS = {
  'branch': branch,
  'version': version,
  'cust-branch': cust_branch,
  'migrate-cust-branch': migrate_cust_branch,
}

def parse_args(args):
  op = OptionParser(usage = __usage)
  op.add_option('-y', '--yes', action='store_true')
  op.add_option('-v', '--verbose', action='store_true')
  op.add_option('-n', '--no-patch-count', action='store_true')
  op.add_option('-p', '--prefix')
  opts, args = op.parse_args()
  return opts, args

def main(argv):
  global VERBOSE, AUTOMATIC_YES, PREFIX, NO_PATCH_COUNT
  opts, args = parse_args(argv[1:])
  AUTOMATIC_YES = opts.yes
  VERBOSE = opts.verbose
  NO_PATCH_COUNT = opts.no_patch_count
  if opts.prefix:
    PREFIX = opts.prefix
  
  if len(args) == 0:
    usage(argv)
  tool = args[0]
  TOOLS[tool]([argv[0]] + args)

if __name__ == "__main__":
  main(sys.argv)
