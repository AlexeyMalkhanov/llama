#!/usr/bin/env python
# Copyright (c) 2010 Cloudera, inc.
# https://wiki.cloudera.com/display/PRODUCT/Staging+step

import sys
import os, re
import boto
import subprocess
import getpass
from optparse import OptionParser
import time
import cloudera.staging.ElasticIpManager
import cloudera.staging.StageManager
import cloudera.staging.Archive
import cloudera.staging.ArchiveManager
import cloudera.aws.ec2
from cloudera.constants import RepositoryType
from cloudera.utils import display_message, verbose_print, confirm_user_action
import logging




class ErrorEncountered(Exception):
  pass


def get_free_eip(eipManager):
  '''
  Get a free Elastic IP
  '''

  return eipManager.get_first_available_ip()


def boot_ami(archiveManager, options):
  '''
  Boot a new AMI

  @return Return a tuple (Instance, Hostname)
  '''

  display_message("Boot AMI")

  instance = archiveManager.kickOff(options.snapshot, options.security_group_name, options.security_group_desc, options.key_name, options.ami)

  if not instance:
    raise ErrorEncountered("Couldn't boot ami")

  hostname = instance.public_dns_name
  if not hostname:
    raise ErrorEncountered("Couldn't grab the hostname of the newly started instance")

  return instance, hostname


def update_archive(build, key_file, hostname, passphrase_apt, passphrase_yum, cdh_release, freezer_bucket):
  '''
  Update an archive

  @param build Build to de staged
  @param key_file SSH private key filename
  @param hostname Hostname of the archive
  @param passphrase_apt Passphrase used for signing packages in the Apt repository
  @param passphrase_yum Passphrase used for signing packages in the Yum repository
  '''

  display_message("Update newly started instance")
  logHandler = logging.StreamHandler()
  logging.getLogger("paramiko.transport").addHandler(logHandler)

  archive = cloudera.staging.Archive.Archive()

  # Set up instance
  archive.connect(hostname, key_file)
  archive.copy_scripts(hostname, key_file)
  archive.install_packages()
  archive.setup_gpg()

  # Set up gpg-agent for Apt repos
  if passphrase_apt:
    apt_fingerprint = cloudera.utils.gpg_key_fingerprint(RepositoryType.APT)
    archive.start_gpg(RepositoryType.APT)
    archive.get_gpg_env(RepositoryType.APT)
    archive.set_gpg_passphrase(apt_fingerprint, passphrase_apt)

  # Update Apt repos
  archive.update_deb_repo(build, cdh_release, freezer_bucket)

  # Set up gpg-agent for Yum repos
  if passphrase_yum:
    yum_fingerprint = cloudera.utils.gpg_key_fingerprint(RepositoryType.YUM)
    archive.start_gpg(RepositoryType.YUM)
    archive.get_gpg_env(RepositoryType.YUM)
    archive.set_gpg_passphrase(yum_fingerprint, passphrase_yum)

  # Update Yum repos
  archive.update_yum_repo(build, cdh_release)

  # Finalize staging
  archive.finalize_staging(build, cdh_release)
  archive.clean_up()

def main():
  usage = "usage: %prog  [options] --snapshot <snapshot id> --key-name <key name> --key-file <key file> --build <build id>"
  op = OptionParser(usage=usage)
  op.add_option('-d', '--dry-run',
              action="store_true",
              default=False,
              help="Dont do anything just pretend")

  op.add_option('-k','--key-file',
            help="The key file authorized")

  op.add_option('-c','--cdh-release',
            help="CDH release (ex: cdh2)")

  op.add_option('-n','--key-name',
            help="The keyname authorized")

  op.add_option('-b','--build',
            help="The build to deploy")

  op.add_option('--snapshot',
            help="Snapshot to base staging from")

  default_sec_group_desc = 'Open HTTP for Cloudera and SSH for everyone'
  op.add_option('-i','--security-group-desc',
     default=default_sec_group_desc,
     help="Override the default security group Description")

  default_sec_group_name = 'Build-Artifact-%s' % time.strftime('%Y%m%d_%H%M%S',time.gmtime())
  op.add_option('-g','--security-group-name',
    default=default_sec_group_name,
   help="Override the default security group name")

  ami = cloudera.staging.ArchiveManager.ArchiveManager.DEFAULT_AMI
  op.add_option('-a','--ami', default=ami,
    help="The alternative ami to boot: %s"  % ami)

  default_s3_bucket = 'cloudera-freezer'
  op.add_option('-s','--s3-bucket',
    default=default_s3_bucket,
    help="S3 bucket where the build is located")

  op.add_option('--gpg-sign',
      action="store_true",
      default=None,
      help="Sign deployed packages")

  op.add_option('-p', '--promote',
      action="store_true",
      default=False,
      help="Promote instance as official archive")


  (options, args) = op.parse_args()


  if not options.cdh_release:
    op.error('--cdh-release option is mandatory')

  if not options.build:
    op.error('build option is mandatory')

  if not options.snapshot:
    op.error('snapshot option is mandatory')

  if not options.key_file:
    op.error('key-file option is mandatory')

  if not options.key_name:
    op.error('key-file option is mandatory')


  #XXX reprepo seems to insist on signing packages. Haven't found a work around yet
  if not options.gpg_sign:
    op.error('Staging without signing packages is not supported yet. Please add the option --gpg-sign')

  if options.promote:
    cloudera.utils.confirm_user_action("You are about to replace and deploy a new official archive.cloudera.com.")

  # Get pass phrase first so user doesn't have to wait
  passphrase_apt = None
  passphrase_yum = None
  if options.gpg_sign:
    passphrase_apt = getpass.getpass("Please, enter gpg passphrase for Apt repository: ")
    passphrase_yum = getpass.getpass("Please, enter gpg passphrase for Yum repository: ")


  ec2_connection  = boto.connect_ec2()

  eipManager = cloudera.staging.ElasticIpManager.ElasticIpManager()
  stageManager = cloudera.staging.StageManager.StageManager()
  archiveManager = cloudera.staging.ArchiveManager.ArchiveManager(ec2_connection)

  eip = get_free_eip(eipManager)

  if not eip:
    raise ErrorEncountered("No Elastic IP available")
  display_message("Free IP address found: %s"%(eip.public_ip))

  # Boot an instance
  instance, hostname =  boot_ami(archiveManager, options)

  display_message("Updating records about instance id and elastic ip address")
  stageManager.add_instance(instance_id=instance.id, user=getpass.getuser(), security_group=options.security_group_name)

  display_message("Associating IP with instance: %s -> %s" % (eip.public_ip, instance.id))
  ec2_connection.associate_address(instance.id, eip.public_ip)

  verbose_print("Waiting for the address to be effectively associated...")
  cloudera.aws.ec2.wait_for_eip_association_ready()
  update_archive(options.build, options.key_file, eip.public_ip, passphrase_apt, passphrase_yum, options.cdh_release, options.s3_bucket)

  if options.promote:
    # Make this archive become the official one
    archiveManager.promote(instance, eip.public_ip)

main()
