Index: conf/log4j.properties
===================================================================
--- conf/log4j.properties	(revision 726070)
+++ conf/log4j.properties	(working copy)
@@ -1,94 +0,0 @@
-# Define some default values that can be overridden by system properties
-hadoop.root.logger=INFO,console
-hadoop.log.dir=.
-hadoop.log.file=hadoop.log
-
-# Define the root logger to the system property "hadoop.root.logger".
-log4j.rootLogger=${hadoop.root.logger}, EventCounter
-
-# Logging Threshold
-log4j.threshhold=ALL
-
-#
-# Daily Rolling File Appender
-#
-
-log4j.appender.DRFA=org.apache.log4j.DailyRollingFileAppender
-log4j.appender.DRFA.File=${hadoop.log.dir}/${hadoop.log.file}
-
-# Rollver at midnight
-log4j.appender.DRFA.DatePattern=.yyyy-MM-dd
-
-# 30-day backup
-#log4j.appender.DRFA.MaxBackupIndex=30
-log4j.appender.DRFA.layout=org.apache.log4j.PatternLayout
-
-# Pattern format: Date LogLevel LoggerName LogMessage
-log4j.appender.DRFA.layout.ConversionPattern=%d{ISO8601} %p %c: %m%n
-# Debugging Pattern format
-#log4j.appender.DRFA.layout.ConversionPattern=%d{ISO8601} %-5p %c{2} (%F:%M(%L)) - %m%n
-
-
-#
-# console
-# Add "console" to rootlogger above if you want to use this 
-#
-
-log4j.appender.console=org.apache.log4j.ConsoleAppender
-log4j.appender.console.target=System.err
-log4j.appender.console.layout=org.apache.log4j.PatternLayout
-log4j.appender.console.layout.ConversionPattern=%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n
-
-#
-# TaskLog Appender
-#
-
-#Default values
-hadoop.tasklog.taskid=null
-hadoop.tasklog.noKeepSplits=4
-hadoop.tasklog.totalLogFileSize=100
-hadoop.tasklog.purgeLogSplits=true
-hadoop.tasklog.logsRetainHours=12
-
-log4j.appender.TLA=org.apache.hadoop.mapred.TaskLogAppender
-log4j.appender.TLA.taskId=${hadoop.tasklog.taskid}
-log4j.appender.TLA.totalLogFileSize=${hadoop.tasklog.totalLogFileSize}
-
-log4j.appender.TLA.layout=org.apache.log4j.PatternLayout
-log4j.appender.TLA.layout.ConversionPattern=%d{ISO8601} %p %c: %m%n
-
-#
-# Rolling File Appender
-#
-
-#log4j.appender.RFA=org.apache.log4j.RollingFileAppender
-#log4j.appender.RFA.File=${hadoop.log.dir}/${hadoop.log.file}
-
-# Logfile size and and 30-day backups
-#log4j.appender.RFA.MaxFileSize=1MB
-#log4j.appender.RFA.MaxBackupIndex=30
-
-#log4j.appender.RFA.layout=org.apache.log4j.PatternLayout
-#log4j.appender.RFA.layout.ConversionPattern=%d{ISO8601} %-5p %c{2} - %m%n
-#log4j.appender.RFA.layout.ConversionPattern=%d{ISO8601} %-5p %c{2} (%F:%M(%L)) - %m%n
-
-#
-# FSNamesystem Audit logging
-# All audit events are logged at INFO level
-#
-log4j.logger.org.apache.hadoop.fs.FSNamesystem.audit=WARN
-
-# Custom Logging levels
-
-#log4j.logger.org.apache.hadoop.mapred.JobTracker=DEBUG
-#log4j.logger.org.apache.hadoop.mapred.TaskTracker=DEBUG
-#log4j.logger.org.apache.hadoop.fs.FSNamesystem=DEBUG
-
-# Jets3t library
-log4j.logger.org.jets3t.service.impl.rest.httpclient.RestS3Service=ERROR
-
-#
-# Event Counter Appender
-# Sends counts of logging messages at different severity levels to Hadoop Metrics.
-#
-log4j.appender.EventCounter=org.apache.hadoop.metrics.jvm.EventCounter
Index: conf/log4j.xml
===================================================================
--- conf/log4j.xml	(revision 0)
+++ conf/log4j.xml	(revision 0)
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
+  <!-- console appender -->
+  <appender name="console" class="org.apache.log4j.ConsoleAppender">
+    <param name="threshold" value="all"/>
+    <param name="Target" value="System.err"/>
+    <layout class="org.apache.log4j.PatternLayout">
+      <param name="ConversionPattern" value="%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n"/>
+    </layout>
+  </appender>
+
+  <!-- scribe asyncronous appender -->
+  <appender name="scribe-async" class="org.apache.log4j.AsyncAppender">
+    <appender-ref ref="scribe"/>
+  </appender>
+
+  <!-- "regular" scribe appender -->
+  <appender name="scribe" class="com.cloudera.scribe_log4j.ScribeAppender">
+    <param name="threshold" value="all"/>
+    <param name="hostname" value="hostname.domain"/>
+    <layout class="org.apache.log4j.PatternLayout">
+      <param name="ConversionPattern" value="%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n"/>
+    </layout>
+  </appender>
+
+  <!-- EventCounter appender -->
+  <appender name="EventCounter" class="org.apache.hadoop.metrics.jvm.EventCounter">
+    <param name="threshold" value="all"/>
+  </appender>
+
+  <!-- DRFA appender (not used currently) -->
+  <appender name="DRFA" class="org.apache.log4j.DailyRollingFileAppender">
+    <param name="threshold" value="all"/>
+    <param name="File" value="./hadoop.log"/>
+    <param name="DatePattern" value=".yyyy-MM-dd"/>
+    <layout class="org.apache.log4j.PatternLayout">
+      <param name="ConversationPattern" value="%d{ISO8601} %p %c: %m%n"/>
+    </layout>
+  </appender>
+
+  <!-- TLA appender (not used currently) -->
+  <appender name="TLA" class="org.apache.hadoop.mapred.TaskLogAppender">
+    <param name="threshold" value="all"/>
+    <param name="taskID" value="null"/>
+    <param name="totalLogFileSize" value="100"/>
+    <layout class="org.apache.log4j.PatternLayout">
+      <param name="ConversationPattern" value="%d{ISO8601} %p %c: %m%n"/>
+    </layout>
+  </appender>
+
+  <!-- custom loggers -->
+  <logger name="org.jets3t.service.impl.rest.httpclient.RestS3Service">
+    <level value="error"/>
+  </logger>
+  <logger name="org.apache.hadoop.fs.FSNamesystem.audit">
+    <level value="warn"/>
+  </logger>
+
+  <!-- root logging configuration -->
+  <root>
+    <priority value="info"/>
+
+    <appender-ref ref="console"/>
+    <!--<appender-ref ref="scribe-async"/>-->
+    <appender-ref ref="EventCounter"/>
+  </root>
+</log4j:configuration>
Index: src/contrib/scribe-log4j/lib/libfb303.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/contrib/scribe-log4j/lib/libfb303.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: src/contrib/scribe-log4j/lib/libthrift.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: src/contrib/scribe-log4j/lib/libthrift.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/LogEntry.java
===================================================================
--- src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/LogEntry.java	(revision 0)
+++ src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/LogEntry.java	(revision 0)
@@ -0,0 +1,159 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package com.cloudera.scribe_log4j.thrift;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.HashSet;
+import com.facebook.thrift.*;
+
+import com.facebook.thrift.protocol.*;
+import com.facebook.thrift.transport.*;
+
+public class LogEntry implements TBase, java.io.Serializable {
+  public String category;
+  public static final int CATEGORY = 1;
+  public String message;
+  public static final int MESSAGE = 2;
+
+  public final Isset __isset = new Isset();
+  public static final class Isset implements java.io.Serializable {
+    public boolean category = false;
+    public boolean message = false;
+  }
+
+  public LogEntry() {
+  }
+
+  public LogEntry(
+    String category,
+    String message)
+  {
+    this();
+    this.category = category;
+    this.__isset.category = (category != null);
+    this.message = message;
+    this.__isset.message = (message != null);
+  }
+
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof LogEntry)
+      return this.equals((LogEntry)that);
+    return false;
+  }
+
+  public boolean equals(LogEntry that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_category = true && (this.category != null);
+    boolean that_present_category = true && (that.category != null);
+    if (this_present_category || that_present_category) {
+      if (!(this_present_category && that_present_category))
+        return false;
+      if (!this.category.equals(that.category))
+        return false;
+    }
+
+    boolean this_present_message = true && (this.message != null);
+    boolean that_present_message = true && (that.message != null);
+    if (this_present_message || that_present_message) {
+      if (!(this_present_message && that_present_message))
+        return false;
+      if (!this.message.equals(that.message))
+        return false;
+    }
+
+    return true;
+  }
+
+  public int hashCode() {
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) {
+        break;
+      }
+      switch (field.id)
+      {
+        case CATEGORY:
+          if (field.type == TType.STRING) {
+            this.category = iprot.readString();
+            this.__isset.category = true;
+          } else {
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case MESSAGE:
+          if (field.type == TType.STRING) {
+            this.message = iprot.readString();
+            this.__isset.message = true;
+          } else {
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+          break;
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    TStruct struct = new TStruct("LogEntry");
+    oprot.writeStructBegin(struct);
+    TField field = new TField();
+    if (this.category != null) {
+      field.name = "category";
+      field.type = TType.STRING;
+      field.id = CATEGORY;
+      oprot.writeFieldBegin(field);
+      oprot.writeString(this.category);
+      oprot.writeFieldEnd();
+    }
+    if (this.message != null) {
+      field.name = "message";
+      field.type = TType.STRING;
+      field.id = MESSAGE;
+      oprot.writeFieldBegin(field);
+      oprot.writeString(this.message);
+      oprot.writeFieldEnd();
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  public String toString() {
+    StringBuilder sb = new StringBuilder("LogEntry(");
+    boolean first = true;
+
+    if (!first) sb.append(", ");
+    sb.append("category:");
+    sb.append(this.category);
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("message:");
+    sb.append(this.message);
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+}
+
Index: src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/scribe.java
===================================================================
--- src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/scribe.java	(revision 0)
+++ src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/scribe.java	(revision 0)
@@ -0,0 +1,349 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package com.cloudera.scribe_log4j.thrift;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.HashSet;
+import com.facebook.thrift.*;
+
+import com.facebook.thrift.protocol.*;
+import com.facebook.thrift.transport.*;
+
+public class scribe {
+
+  public interface Iface extends com.facebook.fb303.FacebookService.Iface {
+
+    public int Log(List<LogEntry> messages) throws TException;
+
+  }
+
+  public static class Client extends com.facebook.fb303.FacebookService.Client implements Iface {
+    public Client(TProtocol prot)
+    {
+      this(prot, prot);
+    }
+
+    public Client(TProtocol iprot, TProtocol oprot)
+    {
+      super(iprot, oprot);
+    }
+
+    public int Log(List<LogEntry> messages) throws TException
+    {
+      send_Log(messages);
+      return recv_Log();
+    }
+
+    public void send_Log(List<LogEntry> messages) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("Log", TMessageType.CALL, seqid_));
+      Log_args args = new Log_args();
+      args.messages = messages;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public int recv_Log() throws TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      Log_result result = new Log_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.__isset.success) {
+        return result.success;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "Log failed: unknown result");
+    }
+
+  }
+  public static class Processor extends com.facebook.fb303.FacebookService.Processor implements TProcessor {
+    public Processor(Iface iface)
+    {
+      super(iface);
+      iface_ = iface;
+      processMap_.put("Log", new Log());
+    }
+
+    private Iface iface_;
+
+    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
+    {
+      TMessage msg = iprot.readMessageBegin();
+      ProcessFunction fn = processMap_.get(msg.name);
+      if (fn == null) {
+        TProtocolUtil.skip(iprot, TType.STRUCT);
+        iprot.readMessageEnd();
+        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
+        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
+        x.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+        return true;
+      }
+      fn.process(msg.seqid, iprot, oprot);
+      return true;
+    }
+
+    private class Log implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        Log_args args = new Log_args();
+        args.read(iprot);
+        iprot.readMessageEnd();
+        Log_result result = new Log_result();
+        result.success = iface_.Log(args.messages);
+        result.__isset.success = true;
+        oprot.writeMessageBegin(new TMessage("Log", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
+  }
+
+  public static class Log_args implements TBase, java.io.Serializable   {
+    public List<LogEntry> messages;
+    public static final int MESSAGES = 1;
+
+    public final Isset __isset = new Isset();
+    public static final class Isset implements java.io.Serializable {
+      public boolean messages = false;
+    }
+
+    public Log_args() {
+    }
+
+    public Log_args(
+      List<LogEntry> messages)
+    {
+      this();
+      this.messages = messages;
+      this.__isset.messages = (messages != null);
+    }
+
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof Log_args)
+        return this.equals((Log_args)that);
+      return false;
+    }
+
+    public boolean equals(Log_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_messages = true && (this.messages != null);
+      boolean that_present_messages = true && (that.messages != null);
+      if (this_present_messages || that_present_messages) {
+        if (!(this_present_messages && that_present_messages))
+          return false;
+        if (!this.messages.equals(that.messages))
+          return false;
+      }
+
+      return true;
+    }
+
+    public int hashCode() {
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) {
+          break;
+        }
+        switch (field.id)
+        {
+          case MESSAGES:
+            if (field.type == TType.LIST) {
+              {
+                TList _list0 = iprot.readListBegin();
+                this.messages = new ArrayList<LogEntry>(_list0.size);
+                for (int _i1 = 0; _i1 < _list0.size; ++_i1)
+                {
+                  LogEntry _elem2 = new LogEntry();
+                  _elem2 = new LogEntry();
+                  _elem2.read(iprot);
+                  this.messages.add(_elem2);
+                }
+                iprot.readListEnd();
+              }
+              this.__isset.messages = true;
+            } else {
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      TStruct struct = new TStruct("Log_args");
+      oprot.writeStructBegin(struct);
+      TField field = new TField();
+      if (this.messages != null) {
+        field.name = "messages";
+        field.type = TType.LIST;
+        field.id = MESSAGES;
+        oprot.writeFieldBegin(field);
+        {
+          oprot.writeListBegin(new TList(TType.STRUCT, this.messages.size()));
+          for (LogEntry _iter3 : this.messages)          {
+            _iter3.write(oprot);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    public String toString() {
+      StringBuilder sb = new StringBuilder("Log_args(");
+      boolean first = true;
+
+      if (!first) sb.append(", ");
+      sb.append("messages:");
+      sb.append(this.messages);
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+  }
+
+  public static class Log_result implements TBase, java.io.Serializable   {
+    public int success;
+    public static final int SUCCESS = 0;
+
+    public final Isset __isset = new Isset();
+    public static final class Isset implements java.io.Serializable {
+      public boolean success = false;
+    }
+
+    public Log_result() {
+    }
+
+    public Log_result(
+      int success)
+    {
+      this();
+      this.success = success;
+      this.__isset.success = true;
+    }
+
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof Log_result)
+        return this.equals((Log_result)that);
+      return false;
+    }
+
+    public boolean equals(Log_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true;
+      boolean that_present_success = true;
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (this.success != that.success)
+          return false;
+      }
+
+      return true;
+    }
+
+    public int hashCode() {
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) {
+          break;
+        }
+        switch (field.id)
+        {
+          case SUCCESS:
+            if (field.type == TType.I32) {
+              this.success = iprot.readI32();
+              this.__isset.success = true;
+            } else {
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      TStruct struct = new TStruct("Log_result");
+      oprot.writeStructBegin(struct);
+      TField field = new TField();
+
+      if (this.__isset.success) {
+        field.name = "success";
+        field.type = TType.I32;
+        field.id = SUCCESS;
+        oprot.writeFieldBegin(field);
+        oprot.writeI32(this.success);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    public String toString() {
+      StringBuilder sb = new StringBuilder("Log_result(");
+      boolean first = true;
+
+      if (!first) sb.append(", ");
+      sb.append("success:");
+      sb.append(this.success);
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+  }
+
+}
Index: src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/ResultCode.java
===================================================================
--- src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/ResultCode.java	(revision 0)
+++ src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/thrift/ResultCode.java	(revision 0)
@@ -0,0 +1,12 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package com.cloudera.scribe_log4j.thrift;
+
+
+public class ResultCode {
+  public static final int OK = 0;
+  public static final int TRY_LATER = 1;
+}
Index: src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/ScribeAppender.java
===================================================================
--- src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/ScribeAppender.java	(revision 0)
+++ src/contrib/scribe-log4j/src/java/com/cloudera/scribe_log4j/ScribeAppender.java	(revision 0)
@@ -0,0 +1,108 @@
+package com.cloudera.scribe_log4j;
+
+import org.apache.log4j.AppenderSkeleton;
+import org.apache.log4j.spi.LoggingEvent;
+import org.apache.log4j.spi.LocationInfo;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.net.InetAddress;
+import java.io.IOException;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+
+import com.facebook.thrift.protocol.TBinaryProtocol;
+import com.facebook.thrift.transport.TSocket;
+import com.facebook.thrift.transport.TFramedTransport;
+import com.facebook.thrift.transport.TTransportException;
+import com.facebook.thrift.TException;
+
+import com.cloudera.scribe_log4j.thrift.scribe.Client;
+import com.cloudera.scribe_log4j.thrift.LogEntry;
+
+/*
+ * An implementation of log4j's AppenderSkeleton
+ * that writes its output to a Scribe server
+ * running on the local machine, through port 1463
+ */
+public class ScribeAppender extends AppenderSkeleton {
+  private List<LogEntry> list;
+
+  // Thrift-specific
+  private Client client;
+  private TSocket sock;
+  private TFramedTransport transport;
+  private TBinaryProtocol protocol;
+
+  private String hostname;
+
+  public String getHostname() {
+    return hostname;
+  }
+
+  public void setHostname(String hostname) {
+    this.hostname = hostname;
+  }
+
+  /*
+   * Activates this Appender by opening
+   * a transport to the Scribe server
+   * on the local machine, through port 1463
+   */
+  @Override
+  public void activateOptions() {
+    try {
+      synchronized(this) {
+        // Thrift boilerplate code
+        list = new ArrayList<LogEntry>();
+        sock = new TSocket(new Socket("127.0.0.1", 1463));
+        transport = new TFramedTransport(sock);
+        protocol = new TBinaryProtocol(transport, false, false);
+        client = new Client(protocol, protocol);
+        transport.open();
+      }
+    } catch (Exception e) {
+      // Do nothing, because loss of log data shouldn't
+      // break Hadoop
+    }
+  }
+
+  /*
+   * Appends a log message to Scribe
+   */
+  @Override
+  public void append(LoggingEvent event) {
+    synchronized(this) {
+      String message = this.layout.format(event);
+
+      // get the class that requested the log
+      String callingClass = event.getLocationInformation().getClassName();
+      message = hostname + " " + callingClass + " " + message;
+
+      // write this message to the 'hadoop' category
+      LogEntry entry = new LogEntry("hadoop", message);
+
+      list.clear();
+      list.add(entry);
+
+      try {
+        client.Log(list);
+      } catch (Exception e) {
+        // Do nothing, because loss of log data shouldn't
+        // break Hadoop
+      }
+    }
+  }
+
+  @Override
+  public void close() {
+    transport.close();
+  }
+
+  @Override
+  public boolean requiresLayout() {
+    return true;
+  }
+}
\ No newline at end of file
Index: src/contrib/scribe-log4j/README
===================================================================
--- src/contrib/scribe-log4j/README	(revision 0)
+++ src/contrib/scribe-log4j/README	(revision 0)
@@ -0,0 +1,13 @@
+In order to use this project, you must make sure that your
+log4j.properties has been updated with the file attached
+with this patch.
+
+IMPORTANT: you must also edit the packaged log4j.properties
+file and add a field for log4j.appender.scribe.hostname.  For example:
+
+log4j.appender.scribe.hostname=server1.cloudera.com
+
+The rest for needing this is because hostname information cannot be
+fetched from within Hadoop's runtime, and having the hostname is
+instrumental when disambiguiating between logs from two different
+machines.
\ No newline at end of file
Index: src/contrib/scribe-log4j/build.xml
===================================================================
--- src/contrib/scribe-log4j/build.xml	(revision 0)
+++ src/contrib/scribe-log4j/build.xml	(revision 0)
@@ -0,0 +1,13 @@
+<?xml version="1.0"?>
+
+<!--
+
+(c) Copyright 2008 Cloudera, Inc.
+
+-->
+
+<project name="scribe-log4j" default="jar">
+
+  <import file="../build-contrib.xml"/>
+
+</project>
